% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/means_sversion.R
\name{means_bayes}
\alias{means_bayes}
\title{Calculate Bayes estimates for continuous outcomes}
\usage{
means_bayes(data_YZ_s, data_Z_ns, phi = 0, phi_character = NULL, ndraws = 1500)
}
\arguments{
\item{data_YZ_s}{list for selected sample (Microdata or Summary statistics). See details below for more details.}

\item{data_Z_ns}{list for non-selected sample (Microdata or Summary statistics). See details below for more details.}

\item{phi}{value of phi, fixed to a value between 0 and 1 (defaults to 0)}

\item{phi_character}{draw phi from specific distribution (i.e."\code{runif(1)}", defaults to \code{NULL})
\itemize{
\item If \code{phi_character=NULL}, fix at value set to \code{phi};
\item If \verb{phi_character=} specific distribution (i.e. \code{runif(1)} or \code{rbeta(1,1,1)}), then the value of \code{phi} input to the function is ignored
}}

\item{ndraws}{number of draws}
}
\value{
A \code{ndraws*10} matrix of Bayes estimates with each row containing:
\itemize{
\item \code{phi} : drawn phi in this draw
\item \code{muY_s} : drawn mean of outcome variable for selected sample
\item \code{muY_ns} : drawn mean of outcome variable for non-selected sample
\item \code{sigmaYY_s} : drawn variance of outcome variable for selected sample
\item \code{sigmaYY_ns} : drawn variance of outcome variable for non-selected sample
\item \code{rho_XY_s} : drawn correlation between the proxy and the outcome variable for selected sample
\item \code{muY} : drawn grand mean of outcome variable
\item \code{smub} : drawn SMUB with phi = phi
\item \code{smub0} : drawn SMUB with phi = 0
\item \code{smab} : drawn SMAB
}
}
\description{
Calculate Bayes estimates for continuous outcomes
}
\details{
\describe{
\item{\code{data_YZ_s=list(Y,Z)}(Microdata)}{
\itemize{
\item \code{Y} : \code{n*1} matrix of outcome variable \code{Y}
\item \code{Z} : \code{n*nZparams} matrix of auxiliary variables \code{Z}
}
}
\item{\code{data_YZ_s=list(mean_YZ,var_YZ,n_YZ)}(Summary Statistics)}{
\itemize{
\item \code{mean_YZ} : \code{(1+nZparams)*1} vector of mean (in order) of outcome variable \code{Y} and auxiliary variables \code{Z}
\item \code{var_YZ} : \code{(1+nZparams)*(1+nZparams)} matrix of variance (in order) of outcome variable \code{Y} and auxiliary variables \code{Z}
\item \code{n_YZ} : number of selected sample
}
}
\item{\code{data_Z_ns=list(Z)}(Microdata)}{
\itemize{
\item \code{Z} : \code{(N-n)*nZparams} matrix of auxiliary variables \code{Z}
}
}
\item{\code{data_Z_ns=list(mean_Z, var_Z, n_Z)}(Summary Statistics)}{
\itemize{
\item \code{mean_Z} : \code{nZparams*1} vector of mean of auxiliary variables \code{Z}
\item \code{var_Z} : \code{nZparams*nZparams} matrix of variance of auxiliary variables \code{Z}
\item \code{n_Z} : number of non-selected sample
}
}
}
}
\examples{
set.seed(123)
# num of total sample
N <- 10000
# generate auxiliary variables Z
Z <- rnorm(N, 0, 1)
# define the biserial correlation rho between outcome variable Y and the proxy X
rho <- 0.5
# define the mean of the outcome variable Y
mu_y <- 10
a1 <- rho / sqrt(1 - rho^2)
# generate the observed variable Y
Y <- rnorm(Z, 10 + a1 * Z, 1)
# generate the sample selection indicator S with 0.05 of the population selected
prob <- plogis(-4 + 0.3 * Z + 0.1 * Y)
S <- rbinom(prob, 1, prob)
index_s <- S == 1
index_ns <- S == 0
# generate the list of microdata for selected (data_YZ_s) and non-selected sample (data_Z_ns)
data_YZ_s <- list(Y = Y[index_s], Z = Z[index_s])
data_Z_ns <- list(Z = Z[index_ns])

# draw bayesian result from ppmm model
result <- means_bayes(data_YZ_s, data_Z_ns, phi_character = "runif(1)")

# Use summary statistics for both selected and non-selected sample ------------------------
# generate the list of summary statistics for selected sample (data_YZ_sumry)
data_YZ_sumry <- list(
  mean_YZ = c(mean(Y[index_s]), mean(Z[index_s])),
  var_YZ = var(cbind(Y[index_s], Z[index_s])),
  n_YZ = length(Y[index_s])
)
# generate the list of summary statistics for non-selected sample (data_Z_sumry)
data_Z_sumry <- list(
  mean_Z = mean(Z[index_ns]),
  var_Z = as.matrix(var(Z[index_ns])),
  n_Z = length(Z[index_ns])
)
colnames(data_YZ_sumry$var_YZ) <- c("Y", "Z")
colnames(data_Z_sumry$var_Z) <- c("Z")
result_sumry <- means_bayes(data_YZ_sumry, data_Z_sumry, phi_character = "runif(1)")
}
\seealso{
\code{\link[=means_mle]{means_mle()}}

\code{\link[=prop_bayes]{prop_bayes()}}

\code{\link[=prop_mle]{prop_mle()}}
}
