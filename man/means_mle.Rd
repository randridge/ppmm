% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/means_sversion.R
\name{means_mle}
\alias{means_mle}
\title{Calculate maximum likelihood estimates for continuous outcomes}
\usage{
means_mle(data_YZ_s, data_Z_ns, phi = c(0, 0.5, 1))
}
\arguments{
\item{data_YZ_s}{list for selected sample (Microdata or Summary statistics). See details below for more details.}

\item{data_Z_ns}{list for non-selected sample (Microdata or Summary statistics). See details below for more details.}

\item{phi}{scalar or vector of phi values at which the (S)MUB is calculated, should be in \verb{[0,1]} but values from \verb{[-Inf,1]} are allowed (defaults to \code{c(0, 0.5, 1)})}
}
\value{
A \code{length(phi)*10} matrix of Bayes estimates with each row containing:
\itemize{
\item \code{phi} : corresponding phi
\item \code{muY_s} : ML estimate of the mean of outcome variable for selected sample
\item \code{muY_ns} : ML estimate of the mean of outcome variable for non-selected sample
\item \code{sigmaYY_s} : ML estimate of the variance of outcome variable for selected sample
\item \code{sigmaYY_ns} : ML estimate of the variance of outcome variable for non-selected sample
\item \code{rho_XY_s} : ML estimate of the correlation between the proxy and the outcome variable for selected sample
\item \code{muY} : ML estimate of the population mean of outcome variable
\item \code{smub} : ML estimate of SMUB with phi = phi
\item \code{smub0} : ML estimate of SMUB with phi = 0
\item \code{smab} :  ML estimate of SMAB
}
}
\description{
Calculate maximum likelihood estimates for continuous outcomes
}
\details{
\describe{
\item{\code{data_YZ_s=list(Y,Z)}(Microdata)}{
\itemize{
\item \code{Y} : \code{n*1} matrix of outcome variable \code{Y}
\item \code{Z} : \code{n*nZparams} matrix of auxiliary variables \code{Z}
}
}
\item{\code{data_YZ_s=list(mean_YZ,var_YZ,n_YZ)}(Summary Statistics)}{
\itemize{
\item \code{mean_YZ} : \code{(1+nZparams)*1} vector of mean (in order) of outcome variable \code{Y} and auxiliary variables \code{Z}
\item \code{var_YZ} : \code{(1+nZparams)*(1+nZparams)} matrix of variance (in order) of outcome variable \code{Y} and auxiliary variables \code{Z}
\item \code{n_YZ} : number of selected sample
}
}
\item{\code{data_Z_ns=list(Z)}(Microdata)}{
\itemize{
\item \code{Z} : \code{(N-n)*nZparams} matrix of auxiliary variables \code{Z}
}
}
\item{\code{data_Z_ns=list(mean_Z, var_Z, n_Z)}(Summary Statistics)}{
\itemize{
\item \code{mean_Z} : \code{nZparams*1} vector of mean of auxiliary variables \code{Z}
\item \code{var_Z} : \code{nZparams*nZparams} matrix of variance of auxiliary variables \code{Z}
\item \code{n_Z} : number of non-selected sample
}
}
}
}
\examples{
set.seed(123)
# num of total sample
N <- 10000
# generate auxiliary variables Z
Z <- rnorm(N, 0, 1)
# define the biserial correlation rho between outcome variable Y and the proxy X
rho <- 0.5
# define the mean of the outcome variable Y
mu_y <- 10
a1 <- rho / sqrt(1 - rho^2)
# generate the observed variable Y
Y <- rnorm(Z, 10 + a1 * Z, 1)
# generate the sample selection indicator S with 0.05 of the population selected
prob <- plogis(-4 + 0.3 * Z + 0.1 * Y)
S <- rbinom(prob, 1, prob)
index_s <- S == 1
index_ns <- S == 0
# generate the list of microdata for selected (data_YZ_s) and non-selected sample (data_Z_ns)
data_YZ_s <- list(Y = Y[index_s], Z = Z[index_s])
data_Z_ns <- list(Z = Z[index_ns])

# calculate result from ppmm model with maximum likelihood estimation
result <- means_mle(data_YZ_s, data_Z_ns)

# Use summary statistics for both selected and non-selected sample ------------------------
# generate the list of summary statistics for selected sample (data_YZ_sumry)
data_YZ_sumry <- list(
  mean_YZ = c(mean(Y[index_s]), mean(Z[index_s])),
  var_YZ = var(cbind(Y[index_s], Z[index_s])),
  n_YZ = length(Y[index_s])
)
# generate the list of summary statistics for non-selected sample (data_Z_sumry)
data_Z_sumry <- list(
  mean_Z = mean(Z[index_ns]),
  var_Z = as.matrix(var(Z[index_ns])),
  n_Z = length(Z[index_ns])
)
colnames(data_YZ_sumry$var_YZ) <- c("Y", "Z")
colnames(data_Z_sumry$var_Z) <- c("Z")
result_sumry <- means_mle(data_YZ_sumry, data_Z_sumry)

}
\seealso{
\code{\link[=means_bayes]{means_bayes()}}

\code{\link[=prop_bayes]{prop_bayes()}}

\code{\link[=prop_mle]{prop_mle()}}
}
